term = require('term')
term.clear()

--Создадим два класса, родительский и класс потомок


-- ==========Cоздадим класс Игроки, это родительский класс===============
-- примечание: Я создал класс Игроки, но это не абстрактный класс, так как он позволяет создавать непосредственно
-- экземляр класса, то есть конкрентый объект.  Абтрактные классы можно только наследовать и они должны
-- иметь хотя бы один абстрактный метод, но и производным классом его назвать нельзя, видимо, так как он ни от 
-- какого класса не наследует ни свойств, ни методов.
print('============ ВЫПОЛНЕНИЯ ПРОГРАММКИ  ===========')


ClassPlayers = {} 

-- теперь проинициализируем поля, процедуры и фунции нашего класса 
function ClassPlayers:new(age, uuid, ip) 
	local obj = {} 
	obj.age = age or nil -- возраст, по умолчанию nil 
	obj.uuid = uuid or 'uuid' -- по умолчанию 'uuid' 
	obj.ip = ip or '1.1.1.1' -- по умолчанию '1.1.1.1'
	
	--далее превращаем таблицу в класс
	setmetatable(obj,self) 
	self.__index = self
	return obj -- возвращаем наш объект (экземпляр класса)
end 

-- функция получения свойств 
function ClassPlayers:get() 
	return self.age, self.uuid, self.ip
end 

-- функция изменения свойств
function ClassPlayers:set(age, uuid, ip) 
	self.age = age 
	self.uuid = uuid
	self.ip = ip
end 


-- создадим наших первых игроков! Это конкретные объекты, экземпляры класса Игроки
Alex = ClassPlayers:new(36, "abc-zxc-1234567-vvv", '192.168.1.0') -- мы создали объект Алекс, у которого есть какие-то свойства
Bob = ClassPlayers:new(28, "zxc-qwe-0987654-bbb", '192.168.1.2') -- мы создали объект Боб, у которого есть какие-то свойства

print('>>> проверим объект Алекс')
print(Alex:get())


print('>>> меняем Алекса и проверяем, что получилось')
Alex:set( 35, '111-aaa-bbb', '192.168.1.1') 
print(Alex:get()) 




-- =========Создадим подкласс Администраторы==========
ClassAdmins = {} 

--пусть у этого подкласса будет свой метод Бан и метод Бла-бла, а так же один переназначенный метод гет
function ClassAdmins:blabla() 
	print('Отлично, метот Бла-бла у класса \'Админы\' выполнился') -- здесь может быть все, что угодно, по идее
end

--Админы имеют также медод Бан
function ClassAdmins:ban(user) 
	print ('Юзер '..user..' забанен навеки вечные!!!')
end 

--переназначение метода гет у подкласса Админы
function ClassAdmins:get() 
	return "Это злые админы, всех банят и удаляют моды :)" 
end 

--наследуемся от родительского класса Игроки
setmetatable(ClassAdmins,{__index = ClassPlayers}) 

-- Создаем дефолтного пока игрока ГрингоСтар без свойств, здесь видно, что метод new используется у родительского класса Игроки. Он там уже один раз
-- описан, и его не нужно снова писать в коде и классе для админов. Это, cудя по всему, ключевой момент ООП.

print('>>> Создаем и проверяем нашего Гринго, пока это какая-то какашка по умолчанию')  -- но это уже самостоятельный объект
GringoStar = ClassAdmins:new() --создали админа Гринго со стандарными свойствами ИГРОКА, мы не задали пока ему свойств, хоть и можно было!!!
print(ClassPlayers.get(GringoStar))

print('>>> Меняем нашего Гринго так как ему положено быть')
GringoStar:set(23, "555-666-sssssss-uuu", '192.168.255.255') -- изменили Гринге свойства, метод set ТОЖЕ описан уже в классе ИГРОКИ!!!

print('>>> Вызовем метод гет у Админов')
print(ClassAdmins:get())

print('>>> Вызовем метод гет у Игроков для нашего Гринго')
-- синтаксис: РодительскийКласс.Метод(сам_объект, параметры)
print(ClassPlayers.get(GringoStar))

print('>>> Вызовем метод Бла-бла у Админов')
ClassAdmins:blabla() 

print('>>> Вызовем метод Бан у Админов и в качестве аргумента\nпередадим на растерзание дюпера Васю из 3-А')
ClassAdmins:ban('Вася') 

print('>>> обращаюсь к некоторому свойству Алекса')
print(Alex.age)

print('>>> Меняю его на 50, Alex.age = 50')
Alex.age = 50

print('>>> смотрю свойство age Алекса   : ',Alex.age)
print('>>> смотрю свойство uuid Гринго  : ',GringoStar.uuid)

---Что получилось? Здесь, по идее и замыслу ООП, Гринго обладает всеми свойствами и методами класса Игроки, то есть наследует их,
---а также имеет свои свойтсва и методы класса Админы.